import os
import time
import json
import threading
import logging
import warnings
import requests  # for Discord webhook
import krakenex
from pykrakenapi import KrakenAPI
import pandas as pd
from datetime import datetime, timedelta, timezone
import sys
from logging.handlers import RotatingFileHandler
import websocket  # pip install websocket-client
import schedule
import statistics
from collections import deque
import random  # for dice roll based selection

# --- Monkey Patches for Python 3.11 ---
if not hasattr(threading.Thread, "isAlive"):
    threading.Thread.isAlive = threading.Thread.is_alive
import websocket._app as ws_app_module
if not hasattr(ws_app_module, "warning"):
    ws_app_module.warning = logging.warning

# --- Terminal Colors ---
RESET = "\033[0m"
BOLD = "\033[1m"
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"

warnings.filterwarnings("ignore", category=FutureWarning, message=".*'T' is deprecated.*")

# --- Logging Setup ---
logger = logging.getLogger()
logger.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
file_handler = RotatingFileHandler("orderbook_bot_new3.log", maxBytes=5*1024*1024, backupCount=5)
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)
stream_handler = logging.StreamHandler()
stream_handler.setFormatter(formatter)
logger.addHandler(stream_handler)
logger.propagate = False

# --- Discord Webhook ---
DISCORD_WEBHOOK_URL = os.getenv("DISCORD_WEBHOOK_URL")
def send_discord_alert(message: str, embed: dict = None):
    if not DISCORD_WEBHOOK_URL:
        logging.warning("No DISCORD_WEBHOOK_URL set. Can't send Discord alerts.")
        return
    try:
        payload = {"content": message} if message else {}
        if embed:
            payload["embeds"] = [embed]
        resp = requests.post(DISCORD_WEBHOOK_URL, json=payload)
        if resp.status_code not in [200, 204]:
            logging.error(f"Discord alert failed: {resp.status_code} {resp.text}")
        else:
            logging.info("Discord alert sent successfully.")
    except Exception as e:
        logging.error(f"Error sending Discord alert: {e}")
def notify_discord(message: str):
    send_discord_alert(message)

# --- API Setup ---
API_KEY = os.getenv("KRAKEN_API_KEY")
API_SECRET = os.getenv("KRAKEN_API_SECRET")
if not API_KEY or not API_SECRET:
    raise EnvironmentError("Please set KRAKEN_API_KEY and KRAKEN_API_SECRET environment variables.")
kraken_api = krakenex.API(key=API_KEY, secret=API_SECRET)
kraken = KrakenAPI(kraken_api)

# --- Rate Limiting ---
PUBLIC_CALL_DELAY = 1.0
last_public_call_time = 0
def safe_get_ohlc_data(rest_pair, interval=5, max_retries=3):
    global last_public_call_time
    for _ in range(max_retries):
        now = time.time()
        elapsed = now - last_public_call_time
        if elapsed < PUBLIC_CALL_DELAY:
            time.sleep(PUBLIC_CALL_DELAY - elapsed)
        try:
            ohlc, _ = kraken.get_ohlc_data(rest_pair, interval=interval)
            last_public_call_time = time.time()
            if ohlc is not None and not ohlc.empty:
                ohlc["time"] = pd.to_datetime(ohlc["time"], unit="s", utc=True)
                return ohlc, _
        except Exception as e:
            logging.error(f"Error in safe_get_ohlc_data for {rest_pair}: {e}")
        time.sleep(1)
    return None, None

# --- DCA Pairs: Only U.S.-denominated pairs are used.
# We include Bitcoin plus a selection of popular cryptocurrencies.
DCA_PAIRS = [
    "XBT/USD",   # Bitcoin (priority)
    "XRP/USD",   # Priority
    "SOL/USD",   # (Non-priority now; priority pairs are XRP and BTC)
    "ADA/USD",
    "XLM/USD",
    "DOT/USD",
    "MATIC/USD",
    "LTC/USD",
    "BCH/USD"
]
# Assign PAIRS to DCA_PAIRS for data updates.
PAIRS = DCA_PAIRS

# --- Define WS_TO_REST_PAIR mapping ---
WS_TO_REST_PAIR = {
    "XBT/USD": "XXBTZUSD",
    "XRP/USD": "XXRPZUSD",
    "SOL/USD": "SOLUSD",
    "ADA/USD": "ADAUSD",
    "XLM/USD": "XXLMZUSD",
    "DOT/USD": "DOTUSD",       # Example mapping; adjust as needed.
    "MATIC/USD": "MATICUSD",   # Example mapping.
    "LTC/USD": "XLTCZUSD",
    "BCH/USD": "BCHUSD"
}

# --- Define STATE_FILE ---
STATE_FILE = "DCA LOG5.json"

# --- DCA Configuration ---
DCA_AMOUNT = 1.0   # Dollar amount to invest daily

# --- Global State ---
positions = {pair: [] for pair in PAIRS}
last_trade_time = {pair: 0 for pair in PAIRS}
total_profit = 0.0
wins = 0
losses = 0
latest_prices = {pair: None for pair in PAIRS}
historical_prices = {pair: [] for pair in PAIRS}
current_candles = {pair: None for pair in PAIRS}
chikou_wait = {pair: False for pair in PAIRS}

# --- Dry Run Mode ---
DRY_RUN_MODE = os.getenv("DRY_RUN", "False").lower() in ["true", "1", "t", "yes"]
def notify_dry_run_mode():
    msg = "Trading Bot started in DRY RUN mode. No real orders will be executed."
    print(f"{YELLOW}{msg}{RESET}")
    send_discord_alert(msg)

# --- Hourly Summary (Retained for notifications) ---
def get_24hr_trade_summary():
    now = time.time()
    twenty_four_hours_ago = now - 86400
    total_trades = closed_trades = tp_count = sl_count = 0
    for pair in PAIRS:
        for pos in positions[pair]:
            if pos.get("buy_time", 0) >= twenty_four_hours_ago:
                total_trades += 1
                if pos.get("closed", False):
                    closed_trades += 1
                    if pos.get("closure_type") == "TP":
                        tp_count += 1
                    elif pos.get("closure_type") in ["SL", "Risk Exit"]:
                        sl_count += 1
    fill_ratio = (closed_trades / total_trades * 100) if total_trades > 0 else 0.0
    return total_trades, closed_trades, fill_ratio, tp_count, sl_count

def send_hourly_summary():
    totals = get_24hr_trade_summary()
    ratio_str = f"TP/SL: {totals[3]}/{totals[4]}" if totals[4] > 0 else "N/A"
    summary = (
        f"**24-Hour Trade Summary**\n"
        f"Total Trades: {totals[0]}\n"
        f"Closed Trades: {totals[1]}\n"
        f"Fill Ratio: {totals[2]:.2f}%\n"
        f"TP Fills: {totals[3]}\n"
        f"SL Fills: {totals[4]}\n"
        f"{ratio_str}"
    )
    send_discord_alert(summary)
    logging.info("Hourly summary sent.")

# --- New DCA Summary Functions ---
def print_dca_summary_terminal():
    print("\n=== DCA All-Time Summary ===")
    for pair in PAIRS:
        orders = positions[pair]
        if orders:
            count = len(orders)
            total_invested = sum(order.get("dollar_amount", 0) for order in orders)
            total_volume = sum(order.get("volume", 0) for order in orders)
            avg_price = total_invested / total_volume if total_volume > 0 else 0
            print(f"{pair}: Orders: {count}, Total Invested: ${total_invested:.2f}, Total Volume: {total_volume:.6f}, Avg Price: ${avg_price:.5f}")
        else:
            print(f"{pair}: No DCA orders executed yet.")

def send_dca_summary_discord():
    summary_lines = []
    for pair in PAIRS:
        orders = positions[pair]
        if orders:
            count = len(orders)
            total_invested = sum(order.get("dollar_amount", 0) for order in orders)
            total_volume = sum(order.get("volume", 0) for order in orders)
            avg_price = total_invested / total_volume if total_volume > 0 else 0
            summary_lines.append(f"{pair}: Orders: {count}, Invested: ${total_invested:.2f}, Volume: {total_volume:.6f}, Avg Price: ${avg_price:.5f}")
        else:
            summary_lines.append(f"{pair}: No orders executed yet.")
    summary_message = "\n".join(summary_lines)
    send_discord_alert("**DCA All-Time Summary**\n" + summary_message)

# Schedule the DCA summary to print every 5 minutes and send via Discord every hour.
schedule.every(5).minutes.do(print_dca_summary_terminal)
schedule.every().hour.do(send_dca_summary_discord)

def run_scheduler():
    while True:
        schedule.run_pending()
        time.sleep(60)
threading.Thread(target=run_scheduler, daemon=True).start()

# --- Helper Function for Time Floor ---
def floor_time(dt, delta=timedelta(minutes=5)):
    return dt - (dt - datetime(1970, 1, 1, tzinfo=dt.tzinfo)) % delta

# --- Utility Functions ---
def format_price(pair: str, price: float) -> str:
    decimals = {"XBT/USD": 1, "XRP/USD": 5, "SOL/USD": 2, "XLM/USD": 5,
                "ADA/USD": 5, "DOT/USD": 5, "MATIC/USD": 5,
                "LTC/USD": 2, "BCH/USD": 2}.get(pair, 2)
    return f"{price:.{decimals}f}"

def get_account_balance(asset="ZUSD"):
    try:
        resp = kraken_api.query_private("Balance")
        if resp.get("error"):
            logging.error(f"Balance error: {resp['error']}")
            return 0.0
        return float(resp["result"].get(asset, "0.0"))
    except Exception as e:
        logging.error(f"Error fetching balance: {e}")
        return 0.0

def check_and_notify_insufficient_funds(pair: str) -> bool:
    """
    Check if the account has sufficient funds (in ZUSD) for a DCA order.
    If not, send a Discord notification and return False.
    """
    balance = get_account_balance("ZUSD")
    if balance < DCA_AMOUNT:
        message = f"Insufficient balance for DCA order on {pair}. Balance: {balance}"
        logging.warning(message)
        notify_discord(message)
        return False
    return True

def cancel_order(order_id):
    try:
        resp = kraken_api.query_private("CancelOrder", {"txid": order_id})
        if resp.get("error"):
            logging.error(f"Cancel Order Error for {order_id}: {resp['error']}")
            return False
        logging.info(f"Order {order_id} canceled successfully.")
        return True
    except Exception as e:
        logging.error(f"Error canceling order {order_id}: {e}")
        return False

def place_order(pair, side, volume, order_type="market", price=None):
    try:
        if DRY_RUN_MODE:
            logging.info(f"[DRY RUN] {side.upper()} {order_type.upper()} for {pair} at {price if price else 'Market'} (Vol: {volume})")
            return {"order_id": "SIMULATED", "exec_price": price if price else 0.0}
        rest_code = WS_TO_REST_PAIR.get(pair)
        if not rest_code:
            logging.error(f"No REST mapping for {pair}")
            return None
        order_data = {"pair": rest_code, "type": side, "volume": volume}
        if order_type == "market":
            order_data["ordertype"] = "market"
        elif order_type == "limit":
            if not price:
                logging.error("Limit orders require 'price'.")
                return None
            order_data["ordertype"] = "limit"
            order_data["price"] = str(price)
        elif order_type == "take-profit":
            if not price:
                logging.error("Take-Profit requires 'price'.")
                return None
            order_data["ordertype"] = "take-profit-limit"
            order_data["price"] = str(price)
            order_data["price2"] = str(price)
        else:
            logging.error(f"Unknown order_type: {order_type}")
            return None
        resp = kraken_api.query_private("AddOrder", order_data)
        if resp.get("error"):
            logging.error(f"Order Error: {resp['error']}")
            return None
        result = resp.get("result", {})
        txids = result.get("txid")
        if not txids:
            logging.error(f"No txid in AddOrder result: {resp}")
            return None
        order_id = txids[0]
        exec_price = None
        if order_type == "market" and side == "buy":
            time.sleep(1)
            q = kraken_api.query_private("QueryOrders", {"txid": order_id})
            if not q.get("error"):
                info = q["result"].get(order_id, {})
                try:
                    exec_price = float(info.get("price", "0.0"))
                except:
                    exec_price = None
        logging.info(f"Placed {side.upper()} {order_type.upper()} for {pair}: ID={order_id}, Exec={exec_price}")
        return {"order_id": order_id, "exec_price": exec_price}
    except Exception as e:
        logging.error(f"Error placing {side} order for {pair}: {e}")
        return None

def discord_alert_buy(pair, exec_price, volume):
    embed = {
        "title": "ðŸŸ¢ DCA Buy Order Executed",
        "color": 3066993,
        "fields": [
            {"name": "Pair", "value": pair, "inline": True},
            {"name": "Volume", "value": f"{volume:.6f} {pair.split('/')[0]}", "inline": True},
            {"name": "Price", "value": f"${exec_price:.5f}", "inline": True},
            {"name": "Amount", "value": f"${DCA_AMOUNT}", "inline": True}
        ],
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    send_discord_alert("", embed=embed)

def discord_alert_program_start():
    embed = {
        "title": "ðŸš€ Trading Bot (DCA Mode) Started",
        "color": 3066993,
        "description": f"Started at {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC",
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    send_discord_alert("", embed=embed)

def discord_alert_program_stop():
    embed = {
        "title": "ðŸ›‘ Trading Bot (DCA Mode) Stopped",
        "color": 15158332,
        "description": f"Stopped at {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC",
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    send_discord_alert("", embed=embed)

# --- WebSocket Setup ---
WS_URL = "wss://ws.kraken.com/"
ws_app = None
shutting_down = False
def on_ws_open(ws):
    logging.info("WebSocket opened; subscribing to pairs.")
    sub_msg = {"event": "subscribe", "subscription": {"name": "ticker"}, "pair": PAIRS}
    ws.send(json.dumps(sub_msg))
    logging.info("Subscribed to: " + ", ".join(PAIRS))
    fetch_and_merge_rest_data()
def on_ws_message(ws, message):
    try:
        data = json.loads(message)
    except Exception as e:
        logging.error(f"Failed to decode JSON: {e}")
        return
    if not isinstance(data, list) or len(data) < 4 or data[2] != "ticker":
        return
    pair = data[3]
    ticker = data[1]
    if ticker is None or not isinstance(ticker, dict) or "c" not in ticker or not ticker["c"]:
        logging.warning("Ticker data missing for %s", pair)
        return
    try:
        current_price = float(ticker["c"][0])
    except Exception as e:
        logging.error(f"Error converting ticker price for {pair}: {e}")
        return
    latest_prices[pair] = current_price
    now = datetime.now(timezone.utc)
    candle_start = floor_time(now, timedelta(minutes=5))
    if pair not in current_candles or current_candles[pair] is None or current_candles[pair]["timestamp"] != candle_start:
        if pair in current_candles and current_candles[pair] is not None:
            historical_prices[pair].append((
                current_candles[pair]["timestamp"],
                current_candles[pair]["open"],
                current_candles[pair]["high"],
                current_candles[pair]["low"],
                current_candles[pair]["close"]
            ))
            if len(historical_prices[pair]) > 1000:
                historical_prices[pair] = historical_prices[pair][-1000:]
        current_candles[pair] = {
            "timestamp": candle_start,
            "open": current_price,
            "high": current_price,
            "low": current_price,
            "close": current_price
        }
    else:
        candle = current_candles[pair]
        candle["close"] = current_price
        candle["high"] = max(candle["high"], current_price)
        candle["low"] = min(candle["low"], current_price)
def on_ws_error(ws, error):
    logging.error(f"WebSocket error: {error}")
def on_ws_close(ws, close_status_code, close_msg):
    logging.warning(f"WebSocket closed (code={close_status_code}, msg={close_msg})")
    if not shutting_down:
        logging.info("Reconnecting in 5 seconds...")
        t = threading.Timer(5, start_ws_client)
        t.daemon = True
        t.start()
def start_ws_client():
    global ws_app, shutting_down
    ws_app = websocket.WebSocketApp(
        WS_URL,
        on_open=on_ws_open,
        on_message=on_ws_message,
        on_error=on_ws_error,
        on_close=on_ws_close
    )
    ws_app.run_forever(ping_interval=30, ping_timeout=10)
def stop_ws_client():
    global shutting_down
    shutting_down = True
    if ws_app and ws_app.sock and ws_app.sock.connected:
        logging.info("Closing WebSocket intentionally...")
        ws_app.close()

# --- Fetch and Merge REST Data ---
def fetch_and_merge_rest_data():
    for pair in PAIRS:
        rest_pair = WS_TO_REST_PAIR.get(pair)
        if not rest_pair:
            logging.warning(f"No REST mapping for {pair}; skipping REST fetch.")
            continue
        ohlc, _ = safe_get_ohlc_data(rest_pair, interval=5)
        if ohlc is not None and not ohlc.empty:
            ohlc.columns = ["time", "open", "high", "low", "close", "vwap", "volume", "count"]
            ohlc["time"] = pd.to_datetime(ohlc["time"], unit="s", utc=True)
            ohlc.sort_values("time", inplace=True)
            existing_times = set(x[0] for x in historical_prices[pair])
            new_list = []
            for _, row in ohlc.iterrows():
                ts = row["time"]
                if ts not in existing_times:
                    new_list.append((ts, row["open"], row["high"], row["low"], row["close"]))
            if new_list:
                historical_prices[pair].extend(new_list)
                historical_prices[pair] = sorted(historical_prices[pair], key=lambda x: x[0])
                if len(historical_prices[pair]) > 1000:
                    historical_prices[pair] = historical_prices[pair][-1000:]
                logging.info(f"REST fetch: merged {len(new_list)} new candles into {pair}.")
            else:
                logging.info(f"REST fetch: no new candles for {pair}.")
            out_df = pd.DataFrame(historical_prices[pair], columns=["time", "open", "high", "low", "close"])
            out_df.sort_values("time", inplace=True)
            os.makedirs("historical_data", exist_ok=True)
            out_df.to_csv(os.path.join("historical_data", f"{pair.replace('/', '_')}_ohlc.csv"), index=False)
        else:
            logging.warning(f"No fresh data from REST for {pair}.")

def initialize_historical_prices():
    os.makedirs("historical_data", exist_ok=True)
    for pair in PAIRS:
        file_path = os.path.join("historical_data", f"{pair.replace('/', '_')}_ohlc.csv")
        if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
            try:
                df = pd.read_csv(file_path)
                df['time'] = pd.to_datetime(df['time'], errors='coerce', utc=True)
                df.sort_values("time", inplace=True)
                historical_prices[pair] = list(zip(df['time'], df['open'], df['high'], df['low'], df['close']))
                logging.info(f"Loaded {len(historical_prices[pair])} historical OHLC points for {pair}.")
            except Exception as e:
                logging.error(f"Error loading historical data for {pair}: {e}")
        else:
            logging.warning(f"No CSV for {pair}. Starting fresh in memory.")
    fetch_and_merge_rest_data()

def save_state():
    try:
        data = {
            "positions": positions,
            "total_profit": total_profit,
            "last_trade_time": last_trade_time,
            "wins": wins,
            "losses": losses,
        }
        with open(STATE_FILE, "w") as f:
            json.dump(data, f, indent=4)
        logging.info("State saved.")
    except Exception as e:
        logging.error(f"Error saving state: {e}")

def load_state():
    global positions, total_profit, last_trade_time, wins, losses
    if not os.path.exists(STATE_FILE):
        logging.info("No state file found. Starting fresh.")
        return
    try:
        with open(STATE_FILE, "r") as f:
            data = json.load(f)
            positions.update(data.get("positions", {}))
            total_profit = data.get("total_profit", total_profit)
            last_trade_time.update(data.get("last_trade_time", {}))
            wins = data.get("wins", wins)
            losses = data.get("losses", losses)
        logging.info("State loaded.")
    except Exception as e:
        logging.error(f"Error loading state: {e}")

# ===============================
# NEW DCA Logic: Dollar Cost Averaging with Randomized Selection
#
# - Instead of a day-based cycle, the bot now uses a random dice roll to choose which pair to buy.
# - If the dice roll (1-6) is 3 or less, it randomly selects between the priority pairs (XRP/USD and XBT/USD).
# - Otherwise, it randomly selects from the remaining pairs.
# - The bot invests DCA_AMOUNT dollars at market and records the order for an all-time summary.
# - Notifications and logging remain intact.
# ===============================
def get_random_dca_pair():
    roll = random.randint(1, 6)
    if roll <= 3:
        # Priority: choose between XRP and XBT
        return random.choice(["XRP/USD", "XBT/USD"])
    else:
        # Choose randomly from non-priority pairs (exclude XRP and XBT)
        non_priority = [p for p in DCA_PAIRS if p not in ["XRP/USD", "XBT/USD"]]
        return random.choice(non_priority)

def dca_order():
    pair = get_random_dca_pair()
    price = latest_prices.get(pair)
    if price is None:
        logging.warning(f"No latest price available for {pair} for DCA order.")
        notify_discord(f"No latest price available for DCA order on {pair}.")
        return
    # Use the new helper function to check for sufficient funds.
    if not check_and_notify_insufficient_funds(pair):
        return
    volume = DCA_AMOUNT / price
    if DRY_RUN_MODE:
        exec_price = price
        logging.info(f"[DRY RUN] DCA Order: Buying {volume:.6f} of {pair} for ${DCA_AMOUNT} at market price ${price:.5f}")
        notify_discord(f"[DRY RUN] DCA Order Executed: Bought {volume:.6f} of {pair} for ${DCA_AMOUNT} at ${price:.5f}")
        discord_alert_buy(pair, exec_price, volume)
        order_record = {
            "buy_price": exec_price,
            "volume": volume,
            "dollar_amount": DCA_AMOUNT,
            "buy_time": time.time()
        }
        positions[pair].append(order_record)
    else:
        buy_resp = place_order(pair, "buy", volume, "market")
        if buy_resp and buy_resp.get("exec_price") is not None:
            exec_price = buy_resp["exec_price"] or price
            logging.info(f"DCA Order Executed: Bought {volume:.6f} of {pair} for ${DCA_AMOUNT} at ${exec_price:.5f}")
            notify_discord(f"DCA Order Executed: Bought {volume:.6f} of {pair} for ${DCA_AMOUNT} at ${exec_price:.5f}")
            discord_alert_buy(pair, exec_price, volume)
            order_record = {
                "buy_price": exec_price,
                "volume": volume,
                "dollar_amount": DCA_AMOUNT,
                "buy_time": time.time()
            }
            positions[pair].append(order_record)
        else:
            logging.error(f"Failed to execute DCA order for {pair}.")

# Schedule the DCA order to run daily at midnight UTC
schedule.every().day.at("00:00").do(dca_order)

if __name__ == "__main__":
    try:
        discord_alert_program_start()
        if DRY_RUN_MODE:
            msg = "Trading Bot (DCA Mode) started in DRY RUN mode. No real orders will be executed."
            print(f"{YELLOW}{msg}{RESET}")
            send_discord_alert(msg)
        initialize_historical_prices()
        load_state()
        threading.Thread(target=start_ws_client, daemon=True).start()
        logging.info("Starting DCA routine. Daily orders scheduled at 00:00 UTC.")
        # Keep the main thread alive while scheduler runs in its own thread
        while True:
            time.sleep(60)
    except Exception as e:
        logging.error(f"Unhandled exception: {e}")
        discord_alert_program_stop()
        stop_ws_client()
        sys.exit(1)
